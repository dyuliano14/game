import streamlit as st
import os
import random
import time
import json
from src.extractor.pdf_extractor import PDFExtractor
from src.game.engine import GameEngine

def load_css_and_js():
    """Carrega estilos CSS personalizados e JavaScript a partir de arquivos externos."""
    import os
    
    # Criar a pasta static se n√£o existir
    static_dir = os.path.join(os.path.dirname(__file__), 'static')
    if not os.path.exists(static_dir):
        os.makedirs(static_dir)
    
    # Carregar o CSS
    css_path = os.path.join(static_dir, 'styles.css')
    with open(css_path, 'r', encoding='utf-8') as css_file:
        css_content = css_file.read()
        st.markdown(f"<style>{css_content}</style>", unsafe_allow_html=True)
    
    # Carregar o JavaScript
    js_path = os.path.join(static_dir, 'game_interaction.js')
    with open(js_path, 'r', encoding='utf-8') as js_file:
        js_content = js_file.read()
        st.markdown(f"<script>{js_content}</script>", unsafe_allow_html=True)

    /* Estilo para o cabe√ßalho do artigo */
    .article-header {
        background-color: #edf2fb;
        padding: 15px;
        border-radius: 8px;
        border-left: 5px solid #3a86ff;
        margin-bottom: 20px;
        font-size: 22px;
        font-weight: 600;
    }

    /* Estilo para o texto do artigo */
    .article-content {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 25px;
        border: 1px solid #e9ecef;
        font-size: 18px;
        line-height: 1.8;
        margin-bottom: 30px;
    }

    /* Estilo para as palavras com espa√ßos em branco */
    .blank-word {
        background-color: #f8f9fa;
        border: 2px dashed #e63946;
        border-radius: 6px;
        padding: 4px 10px;
        margin: 0 4px;
        display: inline-block;
        font-weight: bold;
        color: #e63946;
        min-width: 70px;
        min-height: 24px;
        text-align: center;
        position: relative;
        vertical-align: middle;
    }
    
    /* Estilo para √°rea de destino quando houver palavra selecionada */
    .highlight-dropzone {
        border: 3px dashed #3a86ff;
        background-color: rgba(168, 218, 220, 0.4) !important;
        box-shadow: 0 0 10px rgba(58, 134, 255, 0.8);
        transition: all 0.3s ease;
        animation: pulsate 1.5s infinite;
    }
    
    @keyframes pulsate {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }
    
    /* Estilo para palavra clic√°vel */
    .keyword-clickable {
        cursor: pointer !important;
        user-select: none;
        transition: all 0.3s ease;
        padding: 8px 12px;
        margin: 8px 4px;
        display: inline-block;
        border: 2px solid transparent;
    }
    
    .keyword-clickable:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    /* Palavra selecionada para coloca√ß√£o */
    .selected-word {
        border: 2px solid #3a86ff;
        background-color: #f1faee;
        box-shadow: 0 0 10px rgba(58, 134, 255, 0.6);
        transform: scale(1.1);
    }
    
    /* Estilo para o espa√ßo ativo que est√° esperando preenchimento */
    .blank-word.active {
        background-color: #ffdddd;
        border: 3px solid #e63946;
        animation: pulse 1.5s infinite;
        color: #e63946 !important;
        font-weight: bold;
        cursor: pointer;
        text-decoration: underline;
        font-size: 18px;
        box-shadow: 0 0 10px rgba(230, 57, 70, 0.7);
        z-index: 10;
        position: relative;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0.8); }
        50% { box-shadow: 0 0 0 8px rgba(230, 57, 70, 0.5); }
        100% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0); }
    }
    
    /* Estilo para palavras preenchidas */
    .filled-word {
        background-color: #a8dadc;
        border-radius: 6px;
        padding: 2px 8px;
        margin: 0 4px;
        display: inline-block;
        font-weight: bold;
        color: #1d3557;
        border: 2px solid #457b9d;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }
    
    .filled-word:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    /* Mantendo a classe blank original para compatibilidade */
    .blank {
        border-bottom: 2px solid #e63946;
        padding: 0 4px;
        margin: 0 2px;
        display: inline-block;
        font-weight: bold;
    }

    /* Estilo para bot√µes de palavras-chave */
    .stButton>button {
        background-color: #f1faee;
        border: 2px solid #a8dadc;
        color: #457b9d;
        font-weight: 500;
        border-radius: 8px;
        padding: 10px 15px;
        transition: all 0.3s;
        cursor: pointer;
    }

    .stButton>button:hover {
        background-color: #a8dadc;
        color: #1d3557;
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    /* Estilo espec√≠fico para bot√µes de a√ß√£o */
    div[data-testid="stHorizontalBlock"] .stButton>button, 
    button[key="next_article"], 
    button[key="clear_btn"],
    button[key="restart_btn"],
    button[key="reset_phase3"] {
        background-color: #457b9d;
        color: white;
        font-weight: 600;
        border: none;
    }
    
    div[data-testid="stHorizontalBlock"] .stButton>button:hover,
    button[key="next_article"]:hover, 
    button[key="clear_btn"]:hover,
    button[key="restart_btn"]:hover,
    button[key="reset_phase3"]:hover {
        background-color: #1d3557;
    }

    /* Estilo para mensagens de feedback */
    .feedback-success {
        background-color: #d4edda;
        color: #155724;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #c3e6cb;
        margin: 20px 0;
    }

    .feedback-error {
        background-color: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #f5c6cb;
        margin: 20px 0;
    }
    
    /* Estilo para a caixa do artigo */
    .article-box {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        border: 1px solid #e9ecef;
        font-size: 18px;
        line-height: 1.8;
        margin-bottom: 20px;
    }
    
    /* Estilos para o pr√≥ximo bot√£o */
    .next-button {
        background-color: #3a86ff;
        color: white;
        padding: 12px 24px;
        font-size: 18px;
        font-weight: 600;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        width: 100%;
        text-align: center;
    }
    
    /* Manter os estilos originais importantes */
    .phase-indicator {
        font-size: 18px;
        font-weight: bold;
        color: #2471A3;
        margin-bottom: 20px;
    }
    
    .progress-bar {
        height: 20px;
        background-color: #e0e0e0;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    
    .progress-fill {
        height: 100%;
        background-color: #4CAF50;
        border-radius: 10px;
        text-align: center;
        line-height: 20px;
        color: white;
    }
    </style>
    
    <script>
    // Fun√ß√£o que ser√° executada quando o conte√∫do da p√°gina estiver carregado
    document.addEventListener('DOMContentLoaded', function() {
        setupClickToPlace();
    });
    
    // Vari√°vel global para armazenar a palavra selecionada atualmente
    let selectedWord = null;
    
    function setupClickToPlace() {
        console.log("Configurando sistema de clique para coloca√ß√£o de palavras");
        
        // Seleciona todas as palavras-chave clic√°veis
        const clickables = document.querySelectorAll('.keyword-clickable');
        console.log(`Encontradas ${clickables.length} palavras clic√°veis`);
        
        const dropzones = document.querySelectorAll('.blank-word');
        console.log(`Encontradas ${dropzones.length} √°reas para coloca√ß√£o`);
        
        // Limpa sele√ß√µes anteriores
        if (selectedWord) {
            const prevSelected = document.querySelector('.selected-word');
            if (prevSelected) {
                prevSelected.classList.remove('selected-word');
            }
            selectedWord = null;
        }
        
        // Adiciona eventos para cada palavra-chave
        clickables.forEach(clickable => {
            // Remove eventos antigos para evitar duplica√ß√£o
            clickable.removeEventListener('click', handleWordClick);
            
            // Adiciona novo evento de clique
            clickable.addEventListener('click', handleWordClick);
            
            // Garante que o estilo de cursor est√° aplicado
            clickable.style.cursor = 'pointer';
        });
        
        // Adiciona eventos para cada zona de clique
        dropzones.forEach(dropzone => {
            // Remove eventos antigos
            dropzone.removeEventListener('click', handleZoneClick);
            
            // Adiciona novo evento de clique
            dropzone.addEventListener('click', handleZoneClick);
            
            // Garante que o estilo de cursor est√° aplicado
            dropzone.style.cursor = 'pointer';
        });
        
        // Adiciona uma mensagem de instru√ß√£o para o usu√°rio
        showInstructionToast("Clique em uma palavra e depois clique em um espa√ßo em branco para coloc√°-la");
    }
    
    function handleWordClick(e) {
        console.log("Palavra clicada:", this.getAttribute('data-word'));
        
        // Remove sele√ß√£o anterior
        const prevSelected = document.querySelector('.selected-word');
        if (prevSelected) {
            prevSelected.classList.remove('selected-word');
        }
        
        // Seleciona esta palavra
        this.classList.add('selected-word');
        selectedWord = {
            element: this,
            word: this.getAttribute('data-word'),
            index: this.getAttribute('data-index')
        };
        
        // Destaca as zonas de coloca√ß√£o
        const dropzones = document.querySelectorAll('.blank-word');
        dropzones.forEach(zone => {
            zone.classList.add('highlight-dropzone');
            // Adiciona um efeito visual para destacar ainda mais
            zone.style.border = '3px dashed #3a86ff';
            zone.style.backgroundColor = 'rgba(168, 218, 220, 0.4)';
            zone.style.boxShadow = '0 0 10px rgba(58, 134, 255, 0.8)';
        });
        
        // Mostrar mensagem de instru√ß√£o
        showInstructionToast('Agora clique em um espa√ßo em branco para colocar a palavra');
    }
    
    function handleZoneClick(e) {
        console.log("Zona de coloca√ß√£o clicada");
        
        // Verifica se h√° uma palavra selecionada
        if (!selectedWord) {
            showInstructionToast('Primeiro selecione uma palavra para colocar');
            return;
        }
        
        console.log("Colocando palavra:", selectedWord.word);
        
        // Obt√©m o ID do espa√ßo
        const blankId = this.id.split('_')[1];
        
        // Atualiza visualmente o espa√ßo
        this.innerHTML = selectedWord.word;
        this.classList.add('filled-word');
        this.classList.remove('blank-word', 'active', 'highlight-dropzone');
        
        // Remove estilos inline que podem ter sido aplicados
        this.style.border = '';
        this.style.backgroundColor = '';
        this.style.boxShadow = '';
        
        // Torna o espa√ßo n√£o clic√°vel
        this.style.cursor = 'default';
        
        // Remove a palavra selecionada da lista
        selectedWord.element.style.display = 'none';
        
        // Remove destaque de todas as zonas
        const dropzones = document.querySelectorAll('.blank-word');
        dropzones.forEach(zone => {
            zone.classList.remove('highlight-dropzone');
            zone.style.border = '';
            zone.style.backgroundColor = '';
            zone.style.boxShadow = '';
        });
        
        // Limpa a sele√ß√£o atual
        selectedWord = null;
        
        // Armazenar a palavra antes de limpar a sele√ß√£o
        const wordToPlace = selectedWord.word;
        
        // Limpa a sele√ß√£o atual
        selectedWord = null;
        
        // Comunica com o Streamlit
        try {
            // M√©todo 1: Par√¢metros de URL
            const newParams = new URLSearchParams(window.location.search);
            newParams.set('word_placed', wordToPlace);
            newParams.set('target_blank', blankId);
            
            console.log("Enviando palavra para Streamlit:", newParams.toString());
            
            // Redirecionar para a mesma p√°gina com os novos par√¢metros
            window.location.href = window.location.pathname + '?' + newParams.toString();
        } catch (e) {
            console.error("Erro ao enviar dados para Streamlit:", e);
            showInstructionToast('Erro ao processar palavra. Tente novamente.');
        }
    }
    
    function showInstructionToast(message) {
        // Cria ou atualiza um toast de instru√ß√£o
        let toast = document.getElementById('instruction-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'instruction-toast';
            toast.style.position = 'fixed';
            toast.style.bottom = '30px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.backgroundColor = '#3a86ff';
            toast.style.color = 'white';
            toast.style.padding = '15px 30px';
            toast.style.borderRadius = '8px';
            toast.style.zIndex = '1000';
            toast.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
            toast.style.fontWeight = 'bold';
            toast.style.fontSize = '16px';
            toast.style.textAlign = 'center';
            toast.style.maxWidth = '80%';
            toast.style.animation = 'fadeIn 0.3s ease-in-out';
            document.body.appendChild(toast);
            
            // Adicionamos uma folha de estilo para a anima√ß√£o
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: translate(-50%, 20px); }
                    to { opacity: 1; transform: translate(-50%, 0); }
                }
                @keyframes fadeOut {
                    from { opacity: 1; transform: translate(-50%, 0); }
                    to { opacity: 0; transform: translate(-50%, 20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        toast.textContent = message;
        
        // Garantir visibilidade
        toast.style.opacity = '1';
        
        // Mantenha o toast vis√≠vel por mais tempo
        clearTimeout(toast.timeout);
        toast.timeout = setTimeout(() => {
            if (toast) {
                toast.style.animation = 'fadeOut 0.3s ease-in-out';
                setTimeout(() => {
                    if (toast && toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }, 5000);
        
        // Registrar para depura√ß√£o
        console.log("Toast exibido:", message);
    }
    
    // Inicializar quando o DOM estiver pronto
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupClickToPlace);
    } else {
        setupClickToPlace();
    }
    
    // Tamb√©m reinicializar quando a p√°gina for atualizada pelo Streamlit
    window.addEventListener('load', setupClickToPlace);
    
    // Reinicializar ap√≥s cada atualiza√ß√£o do Streamlit
    const observer = new MutationObserver(function() {
        setupClickToPlace();
    });
    observer.observe(document.body, { childList: true, subtree: true });
    </script>
    """, unsafe_allow_html=True)

def format_text_with_blanks(text, keywords, selected_words=None):
    """
    Formata o texto substituindo palavras-chave por espa√ßos em branco ou palavras selecionadas.
    
    Args:
        text: Texto original
        keywords: Lista de palavras-chave a serem substitu√≠das
        selected_words: Dicion√°rio com as palavras j√° selecionadas {index: palavra}
        
    Returns:
        Texto formatado com HTML para mostrar espa√ßos em branco ou palavras selecionadas
    """
    if selected_words is None:
        selected_words = {}
    
    # Encontrar o pr√≥ximo √≠ndice de espa√ßo vazio e destac√°-lo
    next_blank_idx = None
    for i in range(len(keywords)):
        if i not in selected_words:
            next_blank_idx = i
            break
    
    # Para debug, mostrar as palavras-chave
    # st.write(f"Palavras-chave a serem encontradas: {keywords}")
    # st.write(f"Pr√≥ximo espa√ßo vazio: {next_blank_idx}, Palavra esperada: {keywords[next_blank_idx] if next_blank_idx is not None else 'Nenhum'}")
    
    # Encontrar todas as posi√ß√µes das palavras-chave no texto
    replacements = []
    for idx, keyword in enumerate(keywords):
        # Encontrar todas as ocorr√™ncias da palavra no texto
        start_pos = 0
        while start_pos < len(text):
            pos = text.find(keyword, start_pos)
            if pos == -1:
                break
            
            # Verificar se a palavra n√£o est√° dentro de outra palavra
            is_standalone = True
            
            # Verificar se h√° espa√ßo ou pontua√ß√£o antes
            if pos > 0 and text[pos-1].isalpha():
                is_standalone = False
            
            # Verificar se h√° espa√ßo ou pontua√ß√£o depois
            end_pos = pos + len(keyword)
            if end_pos < len(text) and text[end_pos].isalpha():
                is_standalone = False
            
            if is_standalone:
                if idx in selected_words:
                    # Se a palavra foi selecionada, mostrar a palavra escolhida
                    replacement = f'<span class="filled-word">{selected_words[idx]}</span>'
                else:
                    # Caso contr√°rio, mostrar espa√ßo em branco com ID √∫nico
                    min_width = max(len(keyword) * 8, 50)  # Estimativa de largura em pixels
                    
                    # Adicionar classe 'active' no pr√≥ximo espa√ßo a ser preenchido
                    active_class = " active" if idx == next_blank_idx else ""
                    
                    # Adicionar texto de ajuda para o espa√ßo ativo
                    if idx == next_blank_idx:
                        # Destacar visualmente o espa√ßo ativo como uma √°rea para clicar
                        replacement = f'<span class="blank-word active" id="blank_{idx}" style="min-width: {min_width}px; color: #e63946; font-weight: bold; cursor: pointer;">Clique aqui</span>'
                    else:
                        # Espa√ßos n√£o ativos tamb√©m s√£o √°reas para clicar
                        replacement = f'<span class="blank-word" id="blank_{idx}" style="min-width: {min_width}px; cursor: pointer;">Clique para preencher</span>'
                    
                    # Guardar a posi√ß√£o e o texto de substitui√ß√£o
                    replacements.append((pos, len(keyword), replacement))
                    break
            
            start_pos = pos + 1
    
    # Ordenar as substitui√ß√µes da direita para a esquerda para evitar problemas com √≠ndices
    replacements.sort(reverse=True)
    
    # Aplicar as substitui√ß√µes
    result = list(text)
    for pos, length, replacement in replacements:
        result[pos:pos+length] = replacement
    
    formatted_text = ''.join(result)
    return formatted_text

def main():
    # Configura√ß√µes da p√°gina
    st.set_page_config(layout="wide", page_title="Alego Manus - Jogo de Aprendizado")
    
    # T√≠tulo principal
    st.markdown('<h1 class="main-title">Jogo Interativo de Legisla√ß√£o</h1>', unsafe_allow_html=True)
    
    # Carregar estilos CSS e JavaScript
    load_css_and_js()
    
    # Handler para eventos de coloca√ß√£o de palavras por clique
    if 'word_placed_event' not in st.session_state:
        st.session_state.word_placed_event = None
    
    # Verificar se h√° um evento de coloca√ß√£o de palavra
    word_param = st.query_params.get("word_placed")
    target_param = st.query_params.get("target_blank")
    
    if word_param and target_param:
        try:
            word = word_param
            target_blank = int(target_param)
            
            # Atualizar o estado da sess√£o com a palavra colocada
            if 'selected_words' in st.session_state:
                st.session_state.selected_words[target_blank] = word
                st.session_state.total_questions += 1
                st.session_state.correct_answer = True
                
                # Mostrar toast de confirma√ß√£o
                st.toast(f"Palavra '{word}' colocada no texto!", icon="‚úÖ")
                
                # Limpar os par√¢metros de consulta ap√≥s processamento
                st.query_params.clear()
                st.rerun()
        except Exception as e:
            st.error(f"Erro ao processar evento de coloca√ß√£o de palavra: {e}")
    
    # Inicializa√ß√£o da sess√£o
    if 'game_engine' not in st.session_state:
        # Lista de PDFs dispon√≠veis
        pdf_options = ["Resolu√ß√£o 1.218", "Outro documento 1", "Outro documento 2"]
        selected_pdf = st.selectbox("Selecione o documento de legisla√ß√£o:", pdf_options)
        
        # Na pr√°tica, voc√™ precisaria mapear estas sele√ß√µes para arquivos reais
        pdf_path = "data/resolucao_1218.pdf"  # Caminho de exemplo
        
        if st.button("Iniciar Jogo"):
            with st.spinner("Carregando documento e inicializando jogo..."):
                extractor = PDFExtractor(pdf_path)
                st.session_state.game_engine = GameEngine(extractor)
                st.session_state.game_engine.initialize_game()
                st.session_state.selected_keyword_index = None
                st.session_state.correct_answers = 0
                st.session_state.total_questions = 0
                st.session_state.correct_answer = False
                st.session_state.selected_words = {}  # Armazena palavras selecionadas {index: palavra}
    else:
        # Criar a estrutura de abas
        tab1, tab2, tab3 = st.tabs(["Jogo", "Instru√ß√µes", "Estat√≠sticas"])
        
        with tab1:
            game_engine = st.session_state.game_engine
            current_level = game_engine.get_current_level()
            
            if current_level:
                # Mostrar descri√ß√£o da fase
                st.markdown(f'<div class="phase-indicator">{game_engine.get_phase_description()}</div>', 
                            unsafe_allow_html=True)
                
                # Mostrar barra de progresso
                progress = game_engine.get_completion_percentage()
                st.markdown(f"""
                <div class="progress-bar">
                    <div class="progress-fill" style="width: {progress}%;">{progress:.1f}%</div>
                </div>
                """, unsafe_allow_html=True)
                
                # Container para o artigo
                with st.container():
                    st.markdown('<h3 class="article-header">Artigo em Estudo</h3>', unsafe_allow_html=True)
                    
                    article_container = st.container()
                    with article_container:
                        # Texto do artigo com espa√ßos em branco
                        if game_engine.current_phase == 1 or game_engine.current_phase == 2:
                            # Inicializa o dicion√°rio de palavras selecionadas se necess√°rio
                            if 'selected_words' not in st.session_state:
                                st.session_state.selected_words = {}
                            
                            # Exibir as palavras-chave para depura√ß√£o (remover em produ√ß√£o)
                            # st.write(f"Palavras-chave do n√≠vel atual: {current_level.keywords}")
                            
                            # Fases 1 e 2: Mostrar texto com espa√ßos em branco e bot√µes para sele√ß√£o
                            formatted_text = format_text_with_blanks(
                                current_level.original_text, 
                                current_level.keywords, 
                                st.session_state.selected_words
                            )
                            st.markdown(f'<div class="article-box">{formatted_text}</div>', unsafe_allow_html=True)
                            
                            # Container para as op√ß√µes de palavras-chave
                            with st.container():
                                # Verificar se h√° algum espa√ßo para preencher
                                blank_indices = [i for i in range(len(current_level.keywords)) 
                                              if i not in st.session_state.selected_words]
                                
                                if blank_indices:
                                    st.subheader(f"Como preencher as palavras no texto:")
                                    st.caption("1) Clique em uma palavra abaixo para selecion√°-la. 2) Em seguida, clique em um espa√ßo em branco no texto para coloc√°-la. As palavras podem ser colocadas em qualquer ordem - o importante √© que todas estejam presentes.")
                                
                                # Criar uma lista de palavras dispon√≠veis (excluindo as j√° selecionadas)
                                available_keywords = current_level.keywords.copy()
                                selected_values = list(st.session_state.selected_words.values())
                                for word in selected_values:
                                    if word in available_keywords:
                                        available_keywords.remove(word)
                                
                                # Se todas as palavras foram selecionadas, verificar se est√£o corretas
                                if not available_keywords:
                                    # Verificar apenas se todas as palavras-chave est√£o presentes, sem se preocupar com a posi√ß√£o exata
                                    selected_words_set = set(word.lower() for word in st.session_state.selected_words.values())
                                    keywords_set = set(word.lower() for word in current_level.keywords)
                                    
                                    # Contar quantas palavras est√£o corretas para estat√≠sticas
                                    correct_words = len(selected_words_set.intersection(keywords_set))
                                    st.session_state.correct_answers += correct_words
                                    
                                    # Se todas as palavras necess√°rias est√£o presentes, considerar como correto
                                    if selected_words_set == keywords_set:
                                        st.markdown(f'<div class="feedback-success">Parab√©ns! Voc√™ completou corretamente o artigo!</div>', unsafe_allow_html=True)
                                        current_level.mark_completed()
                                    else:
                                        st.markdown(f'<div class="feedback-error">Algumas palavras n√£o est√£o no lugar correto. Tente novamente!</div>', unsafe_allow_html=True)
                                        if st.button("Recome√ßar", key="restart_btn"):
                                            st.session_state.selected_words = {}
                                            st.rerun()
                                else:
                                    # Usar colunas para organizar as palavras arrast√°veis
                                    cols = st.columns(4)  # Ajustado para 4 colunas
                                    
                                    # Embaralhar as palavras-chave para n√£o dar dicas pela ordem
                                    keywords_to_show = available_keywords.copy()
                                    random.shuffle(keywords_to_show)
                                    
                                    # Exibir as palavras-chave dispon√≠veis como elementos claramente clic√°veis
                                    for i, keyword in enumerate(keywords_to_show):
                                        col_idx = i % 4
                                        # Renderizar cada palavra como um elemento clic√°vel com HTML e √≠cone
                                        cols[col_idx].markdown(
                                            f'<div class="keyword-clickable filled-word" '
                                            f'data-word="{keyword}" data-index="{i}" '
                                            f'style="cursor: pointer; display: flex; align-items: center; justify-content: center;">'
                                            f'<span style="margin-right: 5px;">üëÜ</span>{keyword}</div>',
                                            unsafe_allow_html=True
                                        )
                                    
                                    # Bot√£o para limpar sele√ß√µes
                                    if st.button("Limpar Sele√ß√µes", key="clear_btn"):
                                        st.session_state.selected_words = {}
                                        st.rerun()
                        
                        elif game_engine.current_phase == 3:
                            # Inicializa o dicion√°rio de palavras selecionadas se necess√°rio
                            if 'selected_words' not in st.session_state:
                                st.session_state.selected_words = {}
                            
                            # Fase 3: Texto com espa√ßos em branco e campos para digita√ß√£o
                            formatted_text = format_text_with_blanks(
                                current_level.original_text, 
                                current_level.keywords, 
                                st.session_state.selected_words
                            )
                            st.markdown(f'<div class="article-box">{formatted_text}</div>', unsafe_allow_html=True)
                            
                            # Encontrar o pr√≥ximo √≠ndice de espa√ßo vazio
                            blank_indices = [i for i in range(len(current_level.keywords)) 
                                          if i not in st.session_state.selected_words]
                            
                            if blank_indices:
                                next_blank = blank_indices[0]
                                # Destacar qual palavra estamos buscando
                                st.subheader(f"Digite a palavra para o destaque em vermelho:")
                                st.caption("Digite a palavra que deve preencher o espa√ßo destacado em vermelho no texto.")
                                
                                # Campo para o usu√°rio digitar a palavra
                                user_input = st.text_input("Digite a palavra-chave:", key=f"input_{next_blank}")
                                
                                if st.button("Verificar", key=f"check_{next_blank}"):
                                    if user_input.strip():
                                        # Armazenar a palavra digitada
                                        st.session_state.selected_words[next_blank] = user_input
                                        
                                        # Verificar se a palavra est√° correta
                                        if user_input.lower() == current_level.keywords[next_blank].lower():
                                            st.markdown(f'<div class="feedback-success">Correto! \'{user_input}\' √© a palavra-chave correta.</div>', unsafe_allow_html=True)
                                            st.session_state.correct_answers += 1
                                        else:
                                            st.markdown(f'<div class="feedback-error">Incorreto. A palavra correta era \'{current_level.keywords[next_blank]}\'.</div>', unsafe_allow_html=True)
                                        
                                        st.session_state.total_questions += 1
                                        
                                        # Verificar se todas as palavras foram preenchidas
                                        if len(st.session_state.selected_words) == len(current_level.keywords):
                                            # Contar quantas palavras est√£o corretas
                                            correct_count = sum(1 for idx, word in st.session_state.selected_words.items() 
                                                            if word.lower() == current_level.keywords[idx].lower())
                                            
                                            if correct_count == len(current_level.keywords):
                                                st.markdown(f'<div class="feedback-success">Parab√©ns! Voc√™ completou corretamente o artigo!</div>', unsafe_allow_html=True)
                                                current_level.mark_completed()
                                            else:
                                                st.markdown(f'<div class="feedback-error">Voc√™ completou o artigo com {correct_count} de {len(current_level.keywords)} palavras corretas.</div>', unsafe_allow_html=True)
                                                if st.button("Tentar Novamente", key="retry_btn"):
                                                    st.session_state.selected_words = {}
                                                    st.rerun()
                                        else:
                                            # Ainda h√° palavras para preencher
                                            st.rerun()
                            
                            # Bot√£o para limpar sele√ß√µes
                            if st.button("Recome√ßar", key="reset_phase3"):
                                st.session_state.selected_words = {}
                                st.rerun()
                
                # Temporizador para mostrar o progresso quando a resposta estiver correta
                if st.session_state.get('correct_answer', False):
                    progress_text = "Pr√≥xima palavra em..."
                    my_bar = st.progress(0)
                    
                    for i in range(5):
                        my_bar.progress((i + 1) * 20)
                        time.sleep(0.2)
                    
                    # Resetar estado
                    st.session_state.correct_answer = False
                    st.rerun()
                
                # Verificar se todas as palavras-chave foram completadas para mostrar o bot√£o de pr√≥ximo artigo
                all_keywords_completed = current_level.is_completed()
                if all_keywords_completed:
                    col1, col2, col3 = st.columns([1, 2, 1])
                    with col2:
                        if st.button("Pr√≥ximo Artigo", use_container_width=True, key="next_article"):
                            # Resetar as palavras selecionadas para o pr√≥ximo n√≠vel
                            st.session_state.selected_words = {}
                            has_next = game_engine.advance_level()
                            if not has_next:
                                st.session_state.game_completed = True
                            st.rerun()
                
            elif hasattr(st.session_state, 'game_completed'):
                # Jogo conclu√≠do
                st.success("Parab√©ns! Voc√™ completou todas as fases do jogo!")
                accuracy = 0
                if st.session_state.total_questions > 0:
                    accuracy = (st.session_state.correct_answers / st.session_state.total_questions) * 100
                    
                st.write(f"Sua taxa de acerto: {accuracy:.1f}%")
                st.write(f"Respostas corretas: {st.session_state.correct_answers}")
                st.write(f"Total de quest√µes: {st.session_state.total_questions}")
                
                if st.button("Reiniciar Jogo"):
                    # Limpar o estado da sess√£o para reiniciar
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()
            else:
                st.error("N√£o h√° mais n√≠veis dispon√≠veis.")
                if st.button("Reiniciar Jogo"):
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()
        
        with tab2:
            st.markdown('<h3 class="article-header">Como Jogar</h3>', unsafe_allow_html=True)
            st.write("""
            Este jogo ajuda voc√™ a aprender as legisla√ß√µes da Alego de forma interativa.
            
            1. **Fase 1**: Selecione as palavras-chave corretas no contexto
            2. **Fase 2**: Menos op√ß√µes dispon√≠veis para aumentar a dificuldade
            3. **Fase 3**: Digite as palavras sem dicas
            """)
        
        with tab3:
            st.markdown('<h3 class="article-header">Seu Progresso</h3>', unsafe_allow_html=True)
            
            if 'correct_answers' in st.session_state and 'total_questions' in st.session_state:
                accuracy = 0
                if st.session_state.total_questions > 0:
                    accuracy = (st.session_state.correct_answers / st.session_state.total_questions) * 100
                
                st.write(f"Taxa de acerto: {accuracy:.1f}%")
                st.write(f"Respostas corretas: {st.session_state.correct_answers}")
                st.write(f"Total de quest√µes: {st.session_state.total_questions}")
                
                # Adicionar um gr√°fico ou visualiza√ß√£o do progresso aqui se desejar

if __name__ == "__main__":
    main()
