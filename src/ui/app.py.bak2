import streamlit as st
import os
import random
import time
import json
from src.extractor.pdf_extractor import PDFExtractor
from src.game.engine import GameEngine

def load_css_and_js():
    """Carrega estilos CSS personalizados e JavaScript a partir de arquivos externos."""
    import os
    
    # Criar a pasta static se não existir
    static_dir = os.path.join(os.path.dirname(__file__), 'static')
    if not os.path.exists(static_dir):
        os.makedirs(static_dir)
    
    # Carregar o CSS
    css_path = os.path.join(static_dir, 'styles.css')
    with open(css_path, 'r', encoding='utf-8') as css_file:
        css_content = css_file.read()
        st.markdown(f"<style>{css_content}</style>", unsafe_allow_html=True)
    
    # Carregar o JavaScript
    js_path = os.path.join(static_dir, 'game_interaction.js')
    with open(js_path, 'r', encoding='utf-8') as js_file:
        js_content = js_file.read()
        st.markdown(f"<script>{js_content}</script>", unsafe_allow_html=True)

    /* Estilo para o cabeçalho do artigo */
    .article-header {
        background-color: #edf2fb;
        padding: 15px;
        border-radius: 8px;
        border-left: 5px solid #3a86ff;
        margin-bottom: 20px;
        font-size: 22px;
        font-weight: 600;
    }

    /* Estilo para o texto do artigo */
    .article-content {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 25px;
        border: 1px solid #e9ecef;
        font-size: 18px;
        line-height: 1.8;
        margin-bottom: 30px;
    }

    /* Estilo para as palavras com espaços em branco */
    .blank-word {
        background-color: #f8f9fa;
        border: 2px dashed #e63946;
        border-radius: 6px;
        padding: 4px 10px;
        margin: 0 4px;
        display: inline-block;
        font-weight: bold;
        color: #e63946;
        min-width: 70px;
        min-height: 24px;
        text-align: center;
        position: relative;
        vertical-align: middle;
    }
    
    /* Estilo para área de destino quando houver palavra selecionada */
    .highlight-dropzone {
        border: 3px dashed #3a86ff;
        background-color: rgba(168, 218, 220, 0.4) !important;
        box-shadow: 0 0 10px rgba(58, 134, 255, 0.8);
        transition: all 0.3s ease;
        animation: pulsate 1.5s infinite;
    }
    
    @keyframes pulsate {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }
    
    /* Estilo para palavra clicável */
    .keyword-clickable {
        cursor: pointer !important;
        user-select: none;
        transition: all 0.3s ease;
        padding: 8px 12px;
        margin: 8px 4px;
        display: inline-block;
        border: 2px solid transparent;
    }
    
    .keyword-clickable:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    /* Palavra selecionada para colocação */
    .selected-word {
        border: 2px solid #3a86ff;
        background-color: #f1faee;
        box-shadow: 0 0 10px rgba(58, 134, 255, 0.6);
        transform: scale(1.1);
    }
    
    /* Estilo para o espaço ativo que está esperando preenchimento */
    .blank-word.active {
        background-color: #ffdddd;
        border: 3px solid #e63946;
        animation: pulse 1.5s infinite;
        color: #e63946 !important;
        font-weight: bold;
        cursor: pointer;
        text-decoration: underline;
        font-size: 18px;
        box-shadow: 0 0 10px rgba(230, 57, 70, 0.7);
        z-index: 10;
        position: relative;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0.8); }
        50% { box-shadow: 0 0 0 8px rgba(230, 57, 70, 0.5); }
        100% { box-shadow: 0 0 0 0 rgba(230, 57, 70, 0); }
    }
    
    /* Estilo para palavras preenchidas */
    .filled-word {
        background-color: #a8dadc;
        border-radius: 6px;
        padding: 2px 8px;
        margin: 0 4px;
        display: inline-block;
        font-weight: bold;
        color: #1d3557;
        border: 2px solid #457b9d;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }
    
    .filled-word:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    /* Mantendo a classe blank original para compatibilidade */
    .blank {
        border-bottom: 2px solid #e63946;
        padding: 0 4px;
        margin: 0 2px;
        display: inline-block;
        font-weight: bold;
    }

    /* Estilo para botões de palavras-chave */
    .stButton>button {
        background-color: #f1faee;
        border: 2px solid #a8dadc;
        color: #457b9d;
        font-weight: 500;
        border-radius: 8px;
        padding: 10px 15px;
        transition: all 0.3s;
        cursor: pointer;
    }

    .stButton>button:hover {
        background-color: #a8dadc;
        color: #1d3557;
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    /* Estilo específico para botões de ação */
    div[data-testid="stHorizontalBlock"] .stButton>button, 
    button[key="next_article"], 
    button[key="clear_btn"],
    button[key="restart_btn"],
    button[key="reset_phase3"] {
        background-color: #457b9d;
        color: white;
        font-weight: 600;
        border: none;
    }
    
    div[data-testid="stHorizontalBlock"] .stButton>button:hover,
    button[key="next_article"]:hover, 
    button[key="clear_btn"]:hover,
    button[key="restart_btn"]:hover,
    button[key="reset_phase3"]:hover {
        background-color: #1d3557;
    }

    /* Estilo para mensagens de feedback */
    .feedback-success {
        background-color: #d4edda;
        color: #155724;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #c3e6cb;
        margin: 20px 0;
    }

    .feedback-error {
        background-color: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #f5c6cb;
        margin: 20px 0;
    }
    
    /* Estilo para a caixa do artigo */
    .article-box {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        border: 1px solid #e9ecef;
        font-size: 18px;
        line-height: 1.8;
        margin-bottom: 20px;
    }
    
    /* Estilos para o próximo botão */
    .next-button {
        background-color: #3a86ff;
        color: white;
        padding: 12px 24px;
        font-size: 18px;
        font-weight: 600;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        width: 100%;
        text-align: center;
    }
    
    /* Manter os estilos originais importantes */
    .phase-indicator {
        font-size: 18px;
        font-weight: bold;
        color: #2471A3;
        margin-bottom: 20px;
    }
    
    .progress-bar {
        height: 20px;
        background-color: #e0e0e0;
        border-radius: 10px;
        margin-bottom: 20px;
    }
    
    .progress-fill {
        height: 100%;
        background-color: #4CAF50;
        border-radius: 10px;
        text-align: center;
        line-height: 20px;
        color: white;
    }
    </style>
    
    <script>
    // Função que será executada quando o conteúdo da página estiver carregado
    document.addEventListener('DOMContentLoaded', function() {
        setupClickToPlace();
    });
    
    // Variável global para armazenar a palavra selecionada atualmente
    let selectedWord = null;
    
    function setupClickToPlace() {
        console.log("Configurando sistema de clique para colocação de palavras");
        
        // Seleciona todas as palavras-chave clicáveis
        const clickables = document.querySelectorAll('.keyword-clickable');
        console.log(`Encontradas ${clickables.length} palavras clicáveis`);
        
        const dropzones = document.querySelectorAll('.blank-word');
        console.log(`Encontradas ${dropzones.length} áreas para colocação`);
        
        // Limpa seleções anteriores
        if (selectedWord) {
            const prevSelected = document.querySelector('.selected-word');
            if (prevSelected) {
                prevSelected.classList.remove('selected-word');
            }
            selectedWord = null;
        }
        
        // Adiciona eventos para cada palavra-chave
        clickables.forEach(clickable => {
            // Remove eventos antigos para evitar duplicação
            clickable.removeEventListener('click', handleWordClick);
            
            // Adiciona novo evento de clique
            clickable.addEventListener('click', handleWordClick);
            
            // Garante que o estilo de cursor está aplicado
            clickable.style.cursor = 'pointer';
        });
        
        // Adiciona eventos para cada zona de clique
        dropzones.forEach(dropzone => {
            // Remove eventos antigos
            dropzone.removeEventListener('click', handleZoneClick);
            
            // Adiciona novo evento de clique
            dropzone.addEventListener('click', handleZoneClick);
            
            // Garante que o estilo de cursor está aplicado
            dropzone.style.cursor = 'pointer';
        });
        
        // Adiciona uma mensagem de instrução para o usuário
        showInstructionToast("Clique em uma palavra e depois clique em um espaço em branco para colocá-la");
    }
    
    function handleWordClick(e) {
        console.log("Palavra clicada:", this.getAttribute('data-word'));
        
        // Remove seleção anterior
        const prevSelected = document.querySelector('.selected-word');
        if (prevSelected) {
            prevSelected.classList.remove('selected-word');
        }
        
        // Seleciona esta palavra
        this.classList.add('selected-word');
        selectedWord = {
            element: this,
            word: this.getAttribute('data-word'),
            index: this.getAttribute('data-index')
        };
        
        // Destaca as zonas de colocação
        const dropzones = document.querySelectorAll('.blank-word');
        dropzones.forEach(zone => {
            zone.classList.add('highlight-dropzone');
            // Adiciona um efeito visual para destacar ainda mais
            zone.style.border = '3px dashed #3a86ff';
            zone.style.backgroundColor = 'rgba(168, 218, 220, 0.4)';
            zone.style.boxShadow = '0 0 10px rgba(58, 134, 255, 0.8)';
        });
        
        // Mostrar mensagem de instrução
        showInstructionToast('Agora clique em um espaço em branco para colocar a palavra');
    }
    
    function handleZoneClick(e) {
        console.log("Zona de colocação clicada");
        
        // Verifica se há uma palavra selecionada
        if (!selectedWord) {
            showInstructionToast('Primeiro selecione uma palavra para colocar');
            return;
        }
        
        console.log("Colocando palavra:", selectedWord.word);
        
        // Obtém o ID do espaço
        const blankId = this.id.split('_')[1];
        
        // Atualiza visualmente o espaço
        this.innerHTML = selectedWord.word;
        this.classList.add('filled-word');
        this.classList.remove('blank-word', 'active', 'highlight-dropzone');
        
        // Remove estilos inline que podem ter sido aplicados
        this.style.border = '';
        this.style.backgroundColor = '';
        this.style.boxShadow = '';
        
        // Torna o espaço não clicável
        this.style.cursor = 'default';
        
        // Remove a palavra selecionada da lista
        selectedWord.element.style.display = 'none';
        
        // Remove destaque de todas as zonas
        const dropzones = document.querySelectorAll('.blank-word');
        dropzones.forEach(zone => {
            zone.classList.remove('highlight-dropzone');
            zone.style.border = '';
            zone.style.backgroundColor = '';
            zone.style.boxShadow = '';
        });
        
        // Limpa a seleção atual
        selectedWord = null;
        
        // Armazenar a palavra antes de limpar a seleção
        const wordToPlace = selectedWord.word;
        
        // Limpa a seleção atual
        selectedWord = null;
        
        // Comunica com o Streamlit
        try {
            // Método 1: Parâmetros de URL
            const newParams = new URLSearchParams(window.location.search);
            newParams.set('word_placed', wordToPlace);
            newParams.set('target_blank', blankId);
            
            console.log("Enviando palavra para Streamlit:", newParams.toString());
            
            // Redirecionar para a mesma página com os novos parâmetros
            window.location.href = window.location.pathname + '?' + newParams.toString();
        } catch (e) {
            console.error("Erro ao enviar dados para Streamlit:", e);
            showInstructionToast('Erro ao processar palavra. Tente novamente.');
        }
    }
    
    function showInstructionToast(message) {
        // Cria ou atualiza um toast de instrução
        let toast = document.getElementById('instruction-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'instruction-toast';
            toast.style.position = 'fixed';
            toast.style.bottom = '30px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.backgroundColor = '#3a86ff';
            toast.style.color = 'white';
            toast.style.padding = '15px 30px';
            toast.style.borderRadius = '8px';
            toast.style.zIndex = '1000';
            toast.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
            toast.style.fontWeight = 'bold';
            toast.style.fontSize = '16px';
            toast.style.textAlign = 'center';
            toast.style.maxWidth = '80%';
            toast.style.animation = 'fadeIn 0.3s ease-in-out';
            document.body.appendChild(toast);
            
            // Adicionamos uma folha de estilo para a animação
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; transform: translate(-50%, 20px); }
                    to { opacity: 1; transform: translate(-50%, 0); }
                }
                @keyframes fadeOut {
                    from { opacity: 1; transform: translate(-50%, 0); }
                    to { opacity: 0; transform: translate(-50%, 20px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        toast.textContent = message;
        
        // Garantir visibilidade
        toast.style.opacity = '1';
        
        // Mantenha o toast visível por mais tempo
        clearTimeout(toast.timeout);
        toast.timeout = setTimeout(() => {
            if (toast) {
                toast.style.animation = 'fadeOut 0.3s ease-in-out';
                setTimeout(() => {
                    if (toast && toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }, 5000);
        
        // Registrar para depuração
        console.log("Toast exibido:", message);
    }
    
    // Inicializar quando o DOM estiver pronto
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupClickToPlace);
    } else {
        setupClickToPlace();
    }
    
    // Também reinicializar quando a página for atualizada pelo Streamlit
    window.addEventListener('load', setupClickToPlace);
    
    // Reinicializar após cada atualização do Streamlit
    const observer = new MutationObserver(function() {
        setupClickToPlace();
    });
    observer.observe(document.body, { childList: true, subtree: true });
    </script>
    """, unsafe_allow_html=True)

def format_text_with_blanks(text, keywords, selected_words=None):
    """
    Formata o texto substituindo palavras-chave por espaços em branco ou palavras selecionadas.
    
    Args:
        text: Texto original
        keywords: Lista de palavras-chave a serem substituídas
        selected_words: Dicionário com as palavras já selecionadas {index: palavra}
        
    Returns:
        Texto formatado com HTML para mostrar espaços em branco ou palavras selecionadas
    """
    if selected_words is None:
        selected_words = {}
    
    # Encontrar o próximo índice de espaço vazio e destacá-lo
    next_blank_idx = None
    for i in range(len(keywords)):
        if i not in selected_words:
            next_blank_idx = i
            break
    
    # Para debug, mostrar as palavras-chave
    # st.write(f"Palavras-chave a serem encontradas: {keywords}")
    # st.write(f"Próximo espaço vazio: {next_blank_idx}, Palavra esperada: {keywords[next_blank_idx] if next_blank_idx is not None else 'Nenhum'}")
    
    # Encontrar todas as posições das palavras-chave no texto
    replacements = []
    for idx, keyword in enumerate(keywords):
        # Encontrar todas as ocorrências da palavra no texto
        start_pos = 0
        while start_pos < len(text):
            pos = text.find(keyword, start_pos)
            if pos == -1:
                break
            
            # Verificar se a palavra não está dentro de outra palavra
            is_standalone = True
            
            # Verificar se há espaço ou pontuação antes
            if pos > 0 and text[pos-1].isalpha():
                is_standalone = False
            
            # Verificar se há espaço ou pontuação depois
            end_pos = pos + len(keyword)
            if end_pos < len(text) and text[end_pos].isalpha():
                is_standalone = False
            
            if is_standalone:
                if idx in selected_words:
                    # Se a palavra foi selecionada, mostrar a palavra escolhida
                    replacement = f'<span class="filled-word">{selected_words[idx]}</span>'
                else:
                    # Caso contrário, mostrar espaço em branco com ID único
                    min_width = max(len(keyword) * 8, 50)  # Estimativa de largura em pixels
                    
                    # Adicionar classe 'active' no próximo espaço a ser preenchido
                    active_class = " active" if idx == next_blank_idx else ""
                    
                    # Adicionar texto de ajuda para o espaço ativo
                    if idx == next_blank_idx:
                        # Destacar visualmente o espaço ativo como uma área para clicar
                        replacement = f'<span class="blank-word active" id="blank_{idx}" style="min-width: {min_width}px; color: #e63946; font-weight: bold; cursor: pointer;">Clique aqui</span>'
                    else:
                        # Espaços não ativos também são áreas para clicar
                        replacement = f'<span class="blank-word" id="blank_{idx}" style="min-width: {min_width}px; cursor: pointer;">Clique para preencher</span>'
                    
                    # Guardar a posição e o texto de substituição
                    replacements.append((pos, len(keyword), replacement))
                    break
            
            start_pos = pos + 1
    
    # Ordenar as substituições da direita para a esquerda para evitar problemas com índices
    replacements.sort(reverse=True)
    
    # Aplicar as substituições
    result = list(text)
    for pos, length, replacement in replacements:
        result[pos:pos+length] = replacement
    
    formatted_text = ''.join(result)
    return formatted_text

def main():
    # Configurações da página
    st.set_page_config(layout="wide", page_title="Alego Manus - Jogo de Aprendizado")
    
    # Título principal
    st.markdown('<h1 class="main-title">Jogo Interativo de Legislação</h1>', unsafe_allow_html=True)
    
    # Carregar estilos CSS e JavaScript
    load_css_and_js()
    
    # Handler para eventos de colocação de palavras por clique
    if 'word_placed_event' not in st.session_state:
        st.session_state.word_placed_event = None
    
    # Verificar se há um evento de colocação de palavra
    word_param = st.query_params.get("word_placed")
    target_param = st.query_params.get("target_blank")
    
    if word_param and target_param:
        try:
            word = word_param
            target_blank = int(target_param)
            
            # Atualizar o estado da sessão com a palavra colocada
            if 'selected_words' in st.session_state:
                st.session_state.selected_words[target_blank] = word
                st.session_state.total_questions += 1
                st.session_state.correct_answer = True
                
                # Mostrar toast de confirmação
                st.toast(f"Palavra '{word}' colocada no texto!", icon="✅")
                
                # Limpar os parâmetros de consulta após processamento
                st.query_params.clear()
                st.rerun()
        except Exception as e:
            st.error(f"Erro ao processar evento de colocação de palavra: {e}")
    
    # Inicialização da sessão
    if 'game_engine' not in st.session_state:
        # Lista de PDFs disponíveis
        pdf_options = ["Resolução 1.218", "Outro documento 1", "Outro documento 2"]
        selected_pdf = st.selectbox("Selecione o documento de legislação:", pdf_options)
        
        # Na prática, você precisaria mapear estas seleções para arquivos reais
        pdf_path = "data/resolucao_1218.pdf"  # Caminho de exemplo
        
        if st.button("Iniciar Jogo"):
            with st.spinner("Carregando documento e inicializando jogo..."):
                extractor = PDFExtractor(pdf_path)
                st.session_state.game_engine = GameEngine(extractor)
                st.session_state.game_engine.initialize_game()
                st.session_state.selected_keyword_index = None
                st.session_state.correct_answers = 0
                st.session_state.total_questions = 0
                st.session_state.correct_answer = False
                st.session_state.selected_words = {}  # Armazena palavras selecionadas {index: palavra}
    else:
        # Criar a estrutura de abas
        tab1, tab2, tab3 = st.tabs(["Jogo", "Instruções", "Estatísticas"])
        
        with tab1:
            game_engine = st.session_state.game_engine
            current_level = game_engine.get_current_level()
            
            if current_level:
                # Mostrar descrição da fase
                st.markdown(f'<div class="phase-indicator">{game_engine.get_phase_description()}</div>', 
                            unsafe_allow_html=True)
                
                # Mostrar barra de progresso
                progress = game_engine.get_completion_percentage()
                st.markdown(f"""
                <div class="progress-bar">
                    <div class="progress-fill" style="width: {progress}%;">{progress:.1f}%</div>
                </div>
                """, unsafe_allow_html=True)
                
                # Container para o artigo
                with st.container():
                    st.markdown('<h3 class="article-header">Artigo em Estudo</h3>', unsafe_allow_html=True)
                    
                    article_container = st.container()
                    with article_container:
                        # Texto do artigo com espaços em branco
                        if game_engine.current_phase == 1 or game_engine.current_phase == 2:
                            # Inicializa o dicionário de palavras selecionadas se necessário
                            if 'selected_words' not in st.session_state:
                                st.session_state.selected_words = {}
                            
                            # Exibir as palavras-chave para depuração (remover em produção)
                            # st.write(f"Palavras-chave do nível atual: {current_level.keywords}")
                            
                            # Fases 1 e 2: Mostrar texto com espaços em branco e botões para seleção
                            formatted_text = format_text_with_blanks(
                                current_level.original_text, 
                                current_level.keywords, 
                                st.session_state.selected_words
                            )
                            st.markdown(f'<div class="article-box">{formatted_text}</div>', unsafe_allow_html=True)
                            
                            # Container para as opções de palavras-chave
                            with st.container():
                                # Verificar se há algum espaço para preencher
                                blank_indices = [i for i in range(len(current_level.keywords)) 
                                              if i not in st.session_state.selected_words]
                                
                                if blank_indices:
                                    st.subheader(f"Como preencher as palavras no texto:")
                                    st.caption("1) Clique em uma palavra abaixo para selecioná-la. 2) Em seguida, clique em um espaço em branco no texto para colocá-la. As palavras podem ser colocadas em qualquer ordem - o importante é que todas estejam presentes.")
                                
                                # Criar uma lista de palavras disponíveis (excluindo as já selecionadas)
                                available_keywords = current_level.keywords.copy()
                                selected_values = list(st.session_state.selected_words.values())
                                for word in selected_values:
                                    if word in available_keywords:
                                        available_keywords.remove(word)
                                
                                # Se todas as palavras foram selecionadas, verificar se estão corretas
                                if not available_keywords:
                                    # Verificar apenas se todas as palavras-chave estão presentes, sem se preocupar com a posição exata
                                    selected_words_set = set(word.lower() for word in st.session_state.selected_words.values())
                                    keywords_set = set(word.lower() for word in current_level.keywords)
                                    
                                    # Contar quantas palavras estão corretas para estatísticas
                                    correct_words = len(selected_words_set.intersection(keywords_set))
                                    st.session_state.correct_answers += correct_words
                                    
                                    # Se todas as palavras necessárias estão presentes, considerar como correto
                                    if selected_words_set == keywords_set:
                                        st.markdown(f'<div class="feedback-success">Parabéns! Você completou corretamente o artigo!</div>', unsafe_allow_html=True)
                                        current_level.mark_completed()
                                    else:
                                        st.markdown(f'<div class="feedback-error">Algumas palavras não estão no lugar correto. Tente novamente!</div>', unsafe_allow_html=True)
                                        if st.button("Recomeçar", key="restart_btn"):
                                            st.session_state.selected_words = {}
                                            st.rerun()
                                else:
                                    # Usar colunas para organizar as palavras arrastáveis
                                    cols = st.columns(4)  # Ajustado para 4 colunas
                                    
                                    # Embaralhar as palavras-chave para não dar dicas pela ordem
                                    keywords_to_show = available_keywords.copy()
                                    random.shuffle(keywords_to_show)
                                    
                                    # Exibir as palavras-chave disponíveis como elementos claramente clicáveis
                                    for i, keyword in enumerate(keywords_to_show):
                                        col_idx = i % 4
                                        # Renderizar cada palavra como um elemento clicável com HTML e ícone
                                        cols[col_idx].markdown(
                                            f'<div class="keyword-clickable filled-word" '
                                            f'data-word="{keyword}" data-index="{i}" '
                                            f'style="cursor: pointer; display: flex; align-items: center; justify-content: center;">'
                                            f'<span style="margin-right: 5px;">👆</span>{keyword}</div>',
                                            unsafe_allow_html=True
                                        )
                                    
                                    # Botão para limpar seleções
                                    if st.button("Limpar Seleções", key="clear_btn"):
                                        st.session_state.selected_words = {}
                                        st.rerun()
                        
                        elif game_engine.current_phase == 3:
                            # Inicializa o dicionário de palavras selecionadas se necessário
                            if 'selected_words' not in st.session_state:
                                st.session_state.selected_words = {}
                            
                            # Fase 3: Texto com espaços em branco e campos para digitação
                            formatted_text = format_text_with_blanks(
                                current_level.original_text, 
                                current_level.keywords, 
                                st.session_state.selected_words
                            )
                            st.markdown(f'<div class="article-box">{formatted_text}</div>', unsafe_allow_html=True)
                            
                            # Encontrar o próximo índice de espaço vazio
                            blank_indices = [i for i in range(len(current_level.keywords)) 
                                          if i not in st.session_state.selected_words]
                            
                            if blank_indices:
                                next_blank = blank_indices[0]
                                # Destacar qual palavra estamos buscando
                                st.subheader(f"Digite a palavra para o destaque em vermelho:")
                                st.caption("Digite a palavra que deve preencher o espaço destacado em vermelho no texto.")
                                
                                # Campo para o usuário digitar a palavra
                                user_input = st.text_input("Digite a palavra-chave:", key=f"input_{next_blank}")
                                
                                if st.button("Verificar", key=f"check_{next_blank}"):
                                    if user_input.strip():
                                        # Armazenar a palavra digitada
                                        st.session_state.selected_words[next_blank] = user_input
                                        
                                        # Verificar se a palavra está correta
                                        if user_input.lower() == current_level.keywords[next_blank].lower():
                                            st.markdown(f'<div class="feedback-success">Correto! \'{user_input}\' é a palavra-chave correta.</div>', unsafe_allow_html=True)
                                            st.session_state.correct_answers += 1
                                        else:
                                            st.markdown(f'<div class="feedback-error">Incorreto. A palavra correta era \'{current_level.keywords[next_blank]}\'.</div>', unsafe_allow_html=True)
                                        
                                        st.session_state.total_questions += 1
                                        
                                        # Verificar se todas as palavras foram preenchidas
                                        if len(st.session_state.selected_words) == len(current_level.keywords):
                                            # Contar quantas palavras estão corretas
                                            correct_count = sum(1 for idx, word in st.session_state.selected_words.items() 
                                                            if word.lower() == current_level.keywords[idx].lower())
                                            
                                            if correct_count == len(current_level.keywords):
                                                st.markdown(f'<div class="feedback-success">Parabéns! Você completou corretamente o artigo!</div>', unsafe_allow_html=True)
                                                current_level.mark_completed()
                                            else:
                                                st.markdown(f'<div class="feedback-error">Você completou o artigo com {correct_count} de {len(current_level.keywords)} palavras corretas.</div>', unsafe_allow_html=True)
                                                if st.button("Tentar Novamente", key="retry_btn"):
                                                    st.session_state.selected_words = {}
                                                    st.rerun()
                                        else:
                                            # Ainda há palavras para preencher
                                            st.rerun()
                            
                            # Botão para limpar seleções
                            if st.button("Recomeçar", key="reset_phase3"):
                                st.session_state.selected_words = {}
                                st.rerun()
                
                # Temporizador para mostrar o progresso quando a resposta estiver correta
                if st.session_state.get('correct_answer', False):
                    progress_text = "Próxima palavra em..."
                    my_bar = st.progress(0)
                    
                    for i in range(5):
                        my_bar.progress((i + 1) * 20)
                        time.sleep(0.2)
                    
                    # Resetar estado
                    st.session_state.correct_answer = False
                    st.rerun()
                
                # Verificar se todas as palavras-chave foram completadas para mostrar o botão de próximo artigo
                all_keywords_completed = current_level.is_completed()
                if all_keywords_completed:
                    col1, col2, col3 = st.columns([1, 2, 1])
                    with col2:
                        if st.button("Próximo Artigo", use_container_width=True, key="next_article"):
                            # Resetar as palavras selecionadas para o próximo nível
                            st.session_state.selected_words = {}
                            has_next = game_engine.advance_level()
                            if not has_next:
                                st.session_state.game_completed = True
                            st.rerun()
                
            elif hasattr(st.session_state, 'game_completed'):
                # Jogo concluído
                st.success("Parabéns! Você completou todas as fases do jogo!")
                accuracy = 0
                if st.session_state.total_questions > 0:
                    accuracy = (st.session_state.correct_answers / st.session_state.total_questions) * 100
                    
                st.write(f"Sua taxa de acerto: {accuracy:.1f}%")
                st.write(f"Respostas corretas: {st.session_state.correct_answers}")
                st.write(f"Total de questões: {st.session_state.total_questions}")
                
                if st.button("Reiniciar Jogo"):
                    # Limpar o estado da sessão para reiniciar
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()
            else:
                st.error("Não há mais níveis disponíveis.")
                if st.button("Reiniciar Jogo"):
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()
        
        with tab2:
            st.markdown('<h3 class="article-header">Como Jogar</h3>', unsafe_allow_html=True)
            st.write("""
            Este jogo ajuda você a aprender as legislações da Alego de forma interativa.
            
            1. **Fase 1**: Selecione as palavras-chave corretas no contexto
            2. **Fase 2**: Menos opções disponíveis para aumentar a dificuldade
            3. **Fase 3**: Digite as palavras sem dicas
            """)
        
        with tab3:
            st.markdown('<h3 class="article-header">Seu Progresso</h3>', unsafe_allow_html=True)
            
            if 'correct_answers' in st.session_state and 'total_questions' in st.session_state:
                accuracy = 0
                if st.session_state.total_questions > 0:
                    accuracy = (st.session_state.correct_answers / st.session_state.total_questions) * 100
                
                st.write(f"Taxa de acerto: {accuracy:.1f}%")
                st.write(f"Respostas corretas: {st.session_state.correct_answers}")
                st.write(f"Total de questões: {st.session_state.total_questions}")
                
                # Adicionar um gráfico ou visualização do progresso aqui se desejar

if __name__ == "__main__":
    main()
