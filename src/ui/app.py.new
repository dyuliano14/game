import streamlit as st
import os
import random
import time
import json
from src.extractor.pdf_extractor import PDFExtractor
from src.game.engine import GameEngine

def load_css_and_js():
    """Carrega estilos CSS personalizados e JavaScript a partir de arquivos externos."""
    import os
    
    # Criar a pasta static se n√£o existir
    static_dir = os.path.join(os.path.dirname(__file__), 'static')
    if not os.path.exists(static_dir):
        os.makedirs(static_dir)
    
    # Carregar o CSS
    css_path = os.path.join(static_dir, 'styles.css')
    with open(css_path, 'r', encoding='utf-8') as css_file:
        css_content = css_file.read()
        st.markdown(f"<style>{css_content}</style>", unsafe_allow_html=True)
    
    # Carregar o JavaScript
    js_path = os.path.join(static_dir, 'game_interaction.js')
    with open(js_path, 'r', encoding='utf-8') as js_file:
        js_content = js_file.read()
        st.markdown(f"<script>{js_content}</script>", unsafe_allow_html=True)

def format_text_with_blanks(text, keywords, selected_words=None):
    """
    Formata o texto substituindo palavras-chave por espa√ßos em branco ou palavras selecionadas.
    
    Args:
        text: Texto original
        keywords: Lista de palavras-chave a serem substitu√≠das
        selected_words: Dicion√°rio com as palavras j√° selecionadas {index: palavra}
        
    Returns:
        Texto formatado com HTML para mostrar espa√ßos em branco ou palavras selecionadas
    """
    if selected_words is None:
        selected_words = {}
    
    # Encontrar o pr√≥ximo √≠ndice de espa√ßo vazio e destac√°-lo
    next_blank_idx = None
    for i in range(len(keywords)):
        if i not in selected_words:
            next_blank_idx = i
            break
    
    # Para debug, mostrar as palavras-chave
    # st.write(f"Palavras-chave a serem encontradas: {keywords}")
    # st.write(f"Pr√≥ximo espa√ßo vazio: {next_blank_idx}, Palavra esperada: {keywords[next_blank_idx] if next_blank_idx is not None else 'Nenhum'}")
    
    # Encontrar todas as posi√ß√µes das palavras-chave no texto
    replacements = []
    for idx, keyword in enumerate(keywords):
        # Encontrar todas as ocorr√™ncias da palavra no texto
        start_pos = 0
        while start_pos < len(text):
            pos = text.find(keyword, start_pos)
            if pos == -1:
                break
            
            # Verificar se a palavra n√£o est√° dentro de outra palavra
            is_standalone = True
            
            # Verificar se h√° espa√ßo ou pontua√ß√£o antes
            if pos > 0 and text[pos-1].isalpha():
                is_standalone = False
            
            # Verificar se h√° espa√ßo ou pontua√ß√£o depois
            end_pos = pos + len(keyword)
            if end_pos < len(text) and text[end_pos].isalpha():
                is_standalone = False
            
            if is_standalone:
                if idx in selected_words:
                    # Se a palavra foi selecionada, mostrar a palavra escolhida
                    replacement = f'<span class="filled-word">{selected_words[idx]}</span>'
                else:
                    # Caso contr√°rio, mostrar espa√ßo em branco com ID √∫nico
                    min_width = max(len(keyword) * 8, 50)  # Estimativa de largura em pixels
                    
                    # Adicionar classe 'active' no pr√≥ximo espa√ßo a ser preenchido
                    active_class = " active" if idx == next_blank_idx else ""
                    
                    # Adicionar texto de ajuda para o espa√ßo ativo
                    if idx == next_blank_idx:
                        # Destacar visualmente o espa√ßo ativo como uma √°rea para clicar
                        replacement = f'<span class="blank-word active" id="blank_{idx}" style="min-width: {min_width}px; color: #e63946; font-weight: bold; cursor: pointer;">Clique aqui</span>'
                    else:
                        # Espa√ßos n√£o ativos tamb√©m s√£o √°reas para clicar
                        replacement = f'<span class="blank-word" id="blank_{idx}" style="min-width: {min_width}px; cursor: pointer;">Clique para preencher</span>'
                
                # Guardar a posi√ß√£o e o texto de substitui√ß√£o
                replacements.append((pos, len(keyword), replacement))
                break
            
            start_pos = pos + 1
    
    # Ordenar as substitui√ß√µes da direita para a esquerda para evitar problemas com √≠ndices
    replacements.sort(reverse=True)
    
    # Aplicar as substitui√ß√µes
    result = list(text)
    for pos, length, replacement in replacements:
        result[pos:pos+length] = replacement
    
    formatted_text = ''.join(result)
    return formatted_text

def main():
    # Configura√ß√µes da p√°gina
    st.set_page_config(layout="wide", page_title="Alego Manus - Jogo de Aprendizado")
    
    # T√≠tulo principal
    st.markdown('<h1 class="main-title">Jogo Interativo de Legisla√ß√£o</h1>', unsafe_allow_html=True)
    
    # Carregar estilos CSS e JavaScript
    load_css_and_js()
    
    # Handler para eventos de coloca√ß√£o de palavras por clique
    if 'word_placed_event' not in st.session_state:
        st.session_state.word_placed_event = None
    
    # Verificar se h√° um evento de coloca√ß√£o de palavra
    word_param = st.query_params.get("word_placed")
    target_param = st.query_params.get("target_blank")
    
    if word_param and target_param:
        try:
            word = word_param
            target_blank = int(target_param)
            
            # Atualizar o estado da sess√£o com a palavra colocada
            if 'selected_words' in st.session_state:
                st.session_state.selected_words[target_blank] = word
                st.session_state.total_questions += 1
                st.session_state.correct_answer = True
                
                # Mostrar toast de confirma√ß√£o
                st.toast(f"Palavra '{word}' colocada no texto!", icon="‚úÖ")
                
                # Limpar os par√¢metros de consulta ap√≥s processamento
                st.query_params.clear()
                st.rerun()
        except Exception as e:
            st.error(f"Erro ao processar evento de coloca√ß√£o de palavra: {e}")
    
    # Inicializa√ß√£o da sess√£o
    if 'game_engine' not in st.session_state:
        # Lista de PDFs dispon√≠veis
        pdf_options = ["Resolu√ß√£o 1.218", "Outro documento 1", "Outro documento 2"]
        selected_pdf = st.selectbox("Selecione o documento de legisla√ß√£o:", pdf_options)
        
        # Na pr√°tica, voc√™ precisaria mapear estas sele√ß√µes para arquivos reais
        pdf_path = "data/resolucao_1218.pdf"  # Caminho de exemplo
        
        if st.button("Iniciar Jogo"):
            with st.spinner("Carregando documento e inicializando jogo..."):
                extractor = PDFExtractor(pdf_path)
                st.session_state.game_engine = GameEngine(extractor)
                st.session_state.game_engine.initialize_game()
                st.session_state.selected_keyword_index = None
                st.session_state.correct_answers = 0
                st.session_state.total_questions = 0
                st.session_state.correct_answer = False
                st.session_state.selected_words = {}  # Armazena palavras selecionadas {index: palavra}
    else:
        # Criar a estrutura de abas
        tab1, tab2, tab3 = st.tabs(["Jogo", "Instru√ß√µes", "Estat√≠sticas"])
        
        with tab1:
            game_engine = st.session_state.game_engine
            current_level = game_engine.get_current_level()
            
            if current_level:
                # Mostrar descri√ß√£o da fase
                st.markdown(f'<div class="phase-indicator">{game_engine.get_phase_description()}</div>', 
                            unsafe_allow_html=True)
                
                # Mostrar barra de progresso
                progress = game_engine.get_completion_percentage()
                st.markdown(f"""
                <div class="progress-bar">
                    <div class="progress-fill" style="width: {progress}%;">{progress:.1f}%</div>
                </div>
                """, unsafe_allow_html=True)
                
                # Container para o artigo
                with st.container():
                    st.markdown('<h3 class="article-header">Artigo em Estudo</h3>', unsafe_allow_html=True)
                    
                    article_container = st.container()
                    with article_container:
                        # Texto do artigo com espa√ßos em branco
                        if game_engine.current_phase == 1 or game_engine.current_phase == 2:
                            # Inicializa o dicion√°rio de palavras selecionadas se necess√°rio
                            if 'selected_words' not in st.session_state:
                                st.session_state.selected_words = {}
                            
                            # Exibir as palavras-chave para depura√ß√£o (remover em produ√ß√£o)
                            # st.write(f"Palavras-chave do n√≠vel atual: {current_level.keywords}")
                            
                            # Fases 1 e 2: Mostrar texto com espa√ßos em branco e bot√µes para sele√ß√£o
                            formatted_text = format_text_with_blanks(
                                current_level.original_text, 
                                current_level.keywords, 
                                st.session_state.selected_words
                            )
                            st.markdown(f'<div class="article-box">{formatted_text}</div>', unsafe_allow_html=True)
                            
                            # Container para as op√ß√µes de palavras-chave
                            with st.container():
                                # Verificar se h√° algum espa√ßo para preencher
                                blank_indices = [i for i in range(len(current_level.keywords)) 
                                              if i not in st.session_state.selected_words]
                                
                                if blank_indices:
                                    st.subheader(f"Como preencher as palavras no texto:")
                                    st.caption("1) Clique em uma palavra abaixo para selecion√°-la. 2) Em seguida, clique em um espa√ßo em branco no texto para coloc√°-la. As palavras podem ser colocadas em qualquer ordem - o importante √© que todas estejam presentes.")
                                
                                # Criar uma lista de palavras dispon√≠veis (excluindo as j√° selecionadas)
                                available_keywords = current_level.keywords.copy()
                                selected_values = list(st.session_state.selected_words.values())
                                for word in selected_values:
                                    if word in available_keywords:
                                        available_keywords.remove(word)
                                
                                # Se todas as palavras foram selecionadas, verificar se est√£o corretas
                                if not available_keywords:
                                    # Verificar apenas se todas as palavras-chave est√£o presentes, sem se preocupar com a posi√ß√£o exata
                                    selected_words_set = set(word.lower() for word in st.session_state.selected_words.values())
                                    keywords_set = set(word.lower() for word in current_level.keywords)
                                    
                                    # Contar quantas palavras est√£o corretas para estat√≠sticas
                                    correct_words = len(selected_words_set.intersection(keywords_set))
                                    st.session_state.correct_answers += correct_words
                                    
                                    # Se todas as palavras necess√°rias est√£o presentes, considerar como correto
                                    if selected_words_set == keywords_set:
                                        st.markdown(f'<div class="feedback-success">Parab√©ns! Voc√™ completou corretamente o artigo!</div>', unsafe_allow_html=True)
                                        current_level.mark_completed()
                                    else:
                                        st.markdown(f'<div class="feedback-error">Algumas palavras n√£o est√£o no lugar correto. Tente novamente!</div>', unsafe_allow_html=True)
                                        if st.button("Recome√ßar", key="restart_btn"):
                                            st.session_state.selected_words = {}
                                            st.rerun()
                                else:
                                    # Usar colunas para organizar as palavras arrast√°veis
                                    cols = st.columns(4)  # Ajustado para 4 colunas
                                    
                                    # Embaralhar as palavras-chave para n√£o dar dicas pela ordem
                                    keywords_to_show = available_keywords.copy()
                                    random.shuffle(keywords_to_show)
                                    
                                    # Exibir as palavras-chave dispon√≠veis como elementos claramente clic√°veis
                                    for i, keyword in enumerate(keywords_to_show):
                                        col_idx = i % 4
                                        # Renderizar cada palavra como um elemento clic√°vel com HTML e √≠cone
                                        cols[col_idx].markdown(
                                            f'<div class="keyword-clickable filled-word" '
                                            f'data-word="{keyword}" data-index="{i}" '
                                            f'style="cursor: pointer; display: flex; align-items: center; justify-content: center;">'
                                            f'<span style="margin-right: 5px;">üëÜ</span>{keyword}</div>',
                                            unsafe_allow_html=True
                                        )
                                    
                                    # Bot√£o para limpar sele√ß√µes
                                    if st.button("Limpar Sele√ß√µes", key="clear_btn"):
                                        st.session_state.selected_words = {}
                                        st.rerun()
                        
                        elif game_engine.current_phase == 3:
                            # Inicializa o dicion√°rio de palavras selecionadas se necess√°rio
                            if 'selected_words' not in st.session_state:
                                st.session_state.selected_words = {}
                            
                            # Fase 3: Texto com espa√ßos em branco e campos para digita√ß√£o
                            formatted_text = format_text_with_blanks(
                                current_level.original_text, 
                                current_level.keywords, 
                                st.session_state.selected_words
                            )
                            st.markdown(f'<div class="article-box">{formatted_text}</div>', unsafe_allow_html=True)
                            
                            # Encontrar o pr√≥ximo √≠ndice de espa√ßo vazio
                            blank_indices = [i for i in range(len(current_level.keywords)) 
                                          if i not in st.session_state.selected_words]
                            
                            if blank_indices:
                                next_blank = blank_indices[0]
                                # Destacar qual palavra estamos buscando
                                st.subheader(f"Digite a palavra para o destaque em vermelho:")
                                st.caption("Digite a palavra que deve preencher o espa√ßo destacado em vermelho no texto.")
                                
                                # Campo para o usu√°rio digitar a palavra
                                user_input = st.text_input("Digite a palavra-chave:", key=f"input_{next_blank}")
                                
                                if st.button("Verificar", key=f"check_{next_blank}"):
                                    if user_input.strip():
                                        # Armazenar a palavra digitada
                                        st.session_state.selected_words[next_blank] = user_input
                                        
                                        # Verificar se a palavra est√° correta
                                        if user_input.lower() == current_level.keywords[next_blank].lower():
                                            st.markdown(f'<div class="feedback-success">Correto! \'{user_input}\' √© a palavra-chave correta.</div>', unsafe_allow_html=True)
                                            st.session_state.correct_answers += 1
                                        else:
                                            st.markdown(f'<div class="feedback-error">Incorreto. A palavra correta era \'{current_level.keywords[next_blank]}\'.</div>', unsafe_allow_html=True)
                                        
                                        st.session_state.total_questions += 1
                                        
                                        # Verificar se todas as palavras foram preenchidas
                                        if len(st.session_state.selected_words) == len(current_level.keywords):
                                            # Contar quantas palavras est√£o corretas
                                            correct_count = sum(1 for idx, word in st.session_state.selected_words.items() 
                                                            if word.lower() == current_level.keywords[idx].lower())
                                            
                                            if correct_count == len(current_level.keywords):
                                                st.markdown(f'<div class="feedback-success">Parab√©ns! Voc√™ completou corretamente o artigo!</div>', unsafe_allow_html=True)
                                                current_level.mark_completed()
                                            else:
                                                st.markdown(f'<div class="feedback-error">Voc√™ completou o artigo com {correct_count} de {len(current_level.keywords)} palavras corretas.</div>', unsafe_allow_html=True)
                                                if st.button("Tentar Novamente", key="retry_btn"):
                                                    st.session_state.selected_words = {}
                                                    st.rerun()
                                        else:
                                            # Ainda h√° palavras para preencher
                                            st.rerun()
                            
                            # Bot√£o para limpar sele√ß√µes
                            if st.button("Recome√ßar", key="reset_phase3"):
                                st.session_state.selected_words = {}
                                st.rerun()
                
                # Temporizador para mostrar o progresso quando a resposta estiver correta
                if st.session_state.get('correct_answer', False):
                    progress_text = "Pr√≥xima palavra em..."
                    my_bar = st.progress(0)
                    
                    for i in range(5):
                        my_bar.progress((i + 1) * 20)
                        time.sleep(0.2)
                    
                    # Resetar estado
                    st.session_state.correct_answer = False
                    st.rerun()
                
                # Verificar se todas as palavras-chave foram completadas para mostrar o bot√£o de pr√≥ximo artigo
                all_keywords_completed = current_level.is_completed()
                if all_keywords_completed:
                    col1, col2, col3 = st.columns([1, 2, 1])
                    with col2:
                        if st.button("Pr√≥ximo Artigo", use_container_width=True, key="next_article"):
                            # Resetar as palavras selecionadas para o pr√≥ximo n√≠vel
                            st.session_state.selected_words = {}
                            has_next = game_engine.advance_level()
                            if not has_next:
                                st.session_state.game_completed = True
                            st.rerun()
                
            elif hasattr(st.session_state, 'game_completed'):
                # Jogo conclu√≠do
                st.success("Parab√©ns! Voc√™ completou todas as fases do jogo!")
                accuracy = 0
                if st.session_state.total_questions > 0:
                    accuracy = (st.session_state.correct_answers / st.session_state.total_questions) * 100
                    
                st.write(f"Sua taxa de acerto: {accuracy:.1f}%")
                st.write(f"Respostas corretas: {st.session_state.correct_answers}")
                st.write(f"Total de quest√µes: {st.session_state.total_questions}")
                
                if st.button("Reiniciar Jogo"):
                    # Limpar o estado da sess√£o para reiniciar
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()
            else:
                st.error("N√£o h√° mais n√≠veis dispon√≠veis.")
                if st.button("Reiniciar Jogo"):
                    for key in list(st.session_state.keys()):
                        del st.session_state[key]
                    st.rerun()
        
        with tab2:
            st.markdown('<h3 class="article-header">Como Jogar</h3>', unsafe_allow_html=True)
            st.write("""
            Este jogo ajuda voc√™ a aprender as legisla√ß√µes da Alego de forma interativa.
            
            1. **Fase 1**: Selecione as palavras-chave corretas no contexto
            2. **Fase 2**: Menos op√ß√µes dispon√≠veis para aumentar a dificuldade
            3. **Fase 3**: Digite as palavras sem dicas
            """)
        
        with tab3:
            st.markdown('<h3 class="article-header">Seu Progresso</h3>', unsafe_allow_html=True)
            
            if 'correct_answers' in st.session_state and 'total_questions' in st.session_state:
                accuracy = 0
                if st.session_state.total_questions > 0:
                    accuracy = (st.session_state.correct_answers / st.session_state.total_questions) * 100
                
                st.write(f"Taxa de acerto: {accuracy:.1f}%")
                st.write(f"Respostas corretas: {st.session_state.correct_answers}")
                st.write(f"Total de quest√µes: {st.session_state.total_questions}")
                
                # Adicionar um gr√°fico ou visualiza√ß√£o do progresso aqui se desejar

if __name__ == "__main__":
    main()
